/*
 * This Visitor walks the AST generated by the transformers and produces code.
 * For every input language, can "inherit" the generated visitNode methods.
 */
module.exports = (superClass) => class ExtendedVisitor extends superClass {
  /**
   * Constructor
   */
  constructor() {
    super();
    this.regexFlags = {
      i: 'i', // ignore case
      m: 'm', // multiline
      u: '', // unicode
      y: '', // sticky search
      g: '' // global
    };
  }

  /**
   * Emit ISODate
   *
   * @param {FuncCallExpressionContext} ctx
   * @return {String}
   */
  emitISODate(ctx) {
    let newstr = '';

    ctx.type = this.Types.Date;

    if (!ctx.wasNew) {
      newstr = 'new ';
    }

    const args = ctx.arguments();

    if (!args.argumentList()) {
      return `${newstr}Date()`;
    }

    const argstr = this.checkArguments([[this.Types._string]], args.argumentList());

    return `${newstr}Date(${argstr[0]})`;
  }

  /**
   * Special cased because different target languages need different info out
   * of the constructed date.
   *
   * @param {FuncCallExpressionContext} ctx
   * @param {Date} date
   * @return {String}
   */
  emitDate(ctx, date) {
    let newstr = '';

    if (!ctx.wasNew && this.visit(ctx.singleExpression()) === 'ISODate') {
      newstr = 'new ';
    }

    if (date === undefined) {
      return `${newstr}Date()`;
    }

    const args = ctx.arguments();

    if (!args.argumentList()) {
      return ctx.getText();
    }

    const argstr = this.checkArguments(this.Symbols.Date.args, args.argumentList());

    return `${newstr}Date(${argstr.join(', ')})`;
  }
};
